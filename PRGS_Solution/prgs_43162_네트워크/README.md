## 📖 [네트워크](https://school.programmers.co.kr/learn/courses/30/lessons/43162)
#### 📍 문제
##### 문제 설명
네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.

컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.

##### 제한사항
```
- 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
각 컴퓨터는 0부터 n-1인 정수로 표현합니다.
- i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
- computer[i][i]는 항상 1입니다.
```

##### 입출력 예
<table class="table">
        <thead><tr>
<th>n</th>
<th>computers</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>[[1, 1, 0], [1, 1, 0], [0, 0, 1]]</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>[[1, 1, 0], [1, 1, 1], [0, 1, 1]]</td>
<td>1</td>
</tr>
</tbody>
      </table>

---
#### 📍 풀이
- Union-Find를 이용한 풀이
  - 2차원 배열 `computers`를 순회하며 값이 1인 경우 Union-Find 를 시행한다.
    - 무향 그래프이므로, `c = r + 1` 부터 순회해도 무방하다.
  - `p` 배열을 순회하며 Set을 통해 대표의 개수를 센다.
    - 이 때, 다시 한번 `findset`을 시행해야 정확한 대표의 개수를 알 수 있다.
    - ❗️실수
      - 대표의 개수를 셀 때 `findset`을 시행하지 않았다.
      - 이럴 경우, 같은 네트워크임에도 `p`에 저장된 대표는 다를 수 있기 때문에 오답이 출력된다. 
- DFS를 이용한 풀이
  - 각 노드의 방문여부를 저장하는 1차원 `visited` 배열을 순회하며, 방문하지 않는 점일 경우 `dfs`를 시행한다.
  - `dfs` 함수
    - 매개변수로 입력받은 점 `r`의 `visited` 값을 `true`로 변경한다.
    - `r`을 행으로 하는 `computers` 배열의 열을 순회하며 값이 1이고 방문하지 않은 점에서 다시 `dfs`를 시행하도록 한다.
---
#### 📍 느낀점
- 처음에 Union-Find 방법으로 풀었는데, 대표의 개수를 세는 과정에서 틀린점을 찾지 못해 시간이 꽤 소요됐다. 2025 상반기 현대오토에버 코딩테스트를 응시했을 때, 비슷한 문제를 푼 적이 있는데 그 때도 이 부분에서 같은 실수를 한 것 같다.😢
- DFS 풀이에서는 `computers`를 순회하는 것이 아니라, `visited`를 순회하도록 해야 함을 바로 찾지 못했다. 비슷한 부모 찾기 문제를 많이 풀어봐야겠다. 