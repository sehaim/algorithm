## 📖 [앱](https://www.acmicpc.net/problem/7579)

<img src="./assets/7579_앱.png" />

---

#### 📍 풀이

- 배낭 문제와 같이 2차원 dp를 이용한 풀이
- `dp[i][j]` : i번째의 앱을 종료하고, j의 비용을 썼을 때 확보 가능한 최대 메모리
  - `dp[i-1][j]`와 `dp[i-1][j-costs[i-1]]`을 비교하여 최대 메모리 값을 찾는다.
  - 이후 dp 배열을 순회하며 dp 값이 필요한 메모리 `M` 이상인 곳에서의 비용 `j`가 최소가 되는 지점을 찾는다.

- **실수 1**
  - 초기 설계에서 dp 축을 무조건 `메모리`로 설정해야 풀 수 있는 줄 알았다. 그렇게 하면 2차원 배열이 되었을 때 시간 초과가 되기 때문에 설계에 실패했다.

- **실수 2**
  - gpt로 설계 힌트를 얻고 나서는 dp 비교를 수행할 때 `i - 1`이 아닌 같은 행인 `i`와 비교했다. 

- **실수 3**
  - 인덱스 에러 : `dp` 배열을 `N+1`로 선언했으면 `memories`와 `costs`배열에 접근할 때는 `i - 1`로 해야 한다.

---

#### 📍 느낀점

- 배낭 문제를 풀고 이해를 해도 오랜만에 만나면 계속 헤매게 된다. 주기적으로 비슷한 문제를 풀어야겠다.
- 2차원 배열에서 엣지 케이스 처리를 위해 조건을 설정하는 것 보다 배열을 `N+1`의 크기로 선언하는 것이 더 유리한 케이스들이 많다. 그러나 이 때 인덱스 설정에 유의하고 반드시 검토하도록 하자.
